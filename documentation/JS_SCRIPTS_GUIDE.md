# Guide to JavaScript Deployment & Verification Scripts

This document explains the role of the JavaScript scripts located in the `deployment/` directory, which together form a robust and professional deployment pipeline for the NFT contract.

---

### 1. The Two-Step Pipeline: Deploy then Verify

For this project, we use a professional two-step workflow:

1.  **Deployment (`deployNFT.js`)**: This script's only responsibility is to deploy the smart contract to the blockchain. Upon success, it generates a `.deployment-info-nft.json` file.
2.  **Verification (`verifyNFT.js`)**: This script's only responsibility is to read the info from the JSON file and submit the contract's source code to BscScan for verification.

**Why this approach?**
-   **Robustness**: Sometimes there is a network delay between deployment and when an explorer's API is ready for verification. Separating the steps prevents race conditions.
-   **Error Recovery**: If verification fails (e.g., due to a network issue), you can simply re-run the `verify` script without having to re-deploy the contract and get a new address.
-   **Clarity**: Each script has a single, clear responsibility, which is a core principle of good software design.

---

### 2. The Bridge: `.deployment-info-nft.json`

This file is automatically generated by the deployment script and acts as a "receipt" or a bridge between the two steps. It contains all the data the verification script needs to succeed:

-   `contractAddress`: The unique address of our deployed NFT contract.
-   `deployerAddress`: The first argument passed to the constructor.
-   `baseURI`: The second argument (the IPFS link) passed to the constructor.

---

### 3. Script Breakdown: `deployNFT.js`

This script handles the deployment of the `NFT42` contract.

**Logical Flow**:
1.  **Get Deployer Account**: It starts by calling `ethers.getSigners()` to get the wallet that will pay for the deployment transaction.
2.  **Prepare & Deploy**: It gets the `NFT42` contract factory and calls `.deploy()`, passing in the two required constructor arguments: the deployer's address and the hardcoded IPFS `baseURI`.
3.  **Wait & Log**: It waits for the deployment to be confirmed on the blockchain and then logs the new contract's address to the console.
4.  **Save Info**: Finally, it creates the `deploymentInfo` object and writes it to the `.deployment-info-nft.json` file using Node.js's `fs` module.

---

### 4. Script Breakdown: `verifyNFT.js`

This script automates the process of verifying the contract on BscScan.

**Logical Flow**:
1.  **Read Deployment Info**: It reads the `.deployment-info-nft.json` file to get the contract address and the constructor arguments.
2.  **Handle Errors**: If the file doesn't exist, it exits gracefully with an informative error message.
3.  **Run Verification Task**: It programmatically runs Hardhat's built-in `verify:verify` task. It passes an object containing the `address` and a `constructorArguments` array, which must contain the arguments in the exact same order as the constructor: `[deployerAddress, baseURI]`.
4.  **Manage Existing Verification**: It includes logic to detect if the contract has already been verified, preventing unnecessary errors.

---

### 5. Script Breakdown: `mintNFT.js`

Located in the `mint/` directory, this script automates the process of minting a new NFT after the contract has been deployed.

**Logical Flow**:
1.  **Get Owner Account**: It starts by getting the signer associated with the `PRIVATE_KEY` in the `.env` file. This is the account that will pay the gas fee for the minting transaction.
2.  **Read Deployment Info**: Just like the verification script, it reads the `.deployment-info-nft.json` file to find the address of the contract to interact with.
3.  **Instantiate Contract**: It uses `ethers.getContractAt()` to create a local JavaScript object that represents the smart contract already living on the blockchain.
4.  **Call `safeMint`**: It calls the `safeMint` function of the contract, passing the owner's own address as the recipient.
5.  **Wait for Confirmation**: It sends the transaction and waits for it to be mined and confirmed, then logs a success message.
